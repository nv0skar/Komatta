// Komatta
// Copyright (C) 2022 Oscar
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#![allow(non_snake_case)]

use Komatta::{actions::Action, defaults::*, parameters::Parameters, Cypher};

use clap::{Arg, Command};
use colored::*;
use hex;
use rand::{thread_rng, Rng};
use std::{
    ffi::OsString,
    fs::File,
    io::{BufWriter, Write},
    os::unix::prelude::OsStrExt,
    str::FromStr,
};

pub const OUT_FILE: &'static str = "output.txt";

fn main() {
    let parsed = Command::new(env!("CARGO_PKG_NAME"))
        .version(env!("CARGO_PKG_VERSION"))
        .subcommand_required(true)
        .arg(
            Arg::new("input").help("the string to process")
                .takes_value(true)
                .required(true)
                .allow_invalid_utf8(true)
                .value_parser(clap::value_parser!(OsString)),
        )
        .subcommands([
            Command::new("encrypt").args([
                Arg::new("key").help("the hex value used to encrypt the input")
                    .conflicts_with("keySize")
                    .takes_value(true)
                    .required(false)
                    .value_parser(clap::value_parser!(String)),
                Arg::new("keySize").help(format!("if the key is not present, a randomly generated byte stream with the specified size will be used as the key (the minimum size is {})", MIN_KEY_SIZE).as_str())
                    .long("keySize")
                    .conflicts_with("key")
                    .takes_value(true)
                    .required(false)
                    .value_parser(clap::value_parser!(usize))
                    .default_value(MIN_KEY_SIZE.to_string().as_str()),
                Parameters::format(Arg::new("blockSize").help(format!("sets the block size (the range size is {:?})", BLOCK_SIZE_RANGE).as_str())
                .default_value(BLOCK_SIZE_RANGE.start.to_string().as_str())),
                Parameters::format(Arg::new("keyedHashSize").help(format!("sets the keyed hash output size (the range size is {:?})", KEYED_HASH_SIZE_RANGE).as_str())
                .default_value(KEYED_HASH_SIZE_RANGE.start.to_string().as_str())),
                Parameters::format(Arg::new("ivSize").help(format!("sets the IV size (the range size is {:?})", IV_SIZE_RANGE).as_str())
                .default_value(IV_SIZE_RANGE.start.to_string().as_str())),
                Parameters::format(Arg::new("tagSize").help(format!("sets the tag size (the range size is {:?})", TAG_SIZE_RANGE).as_str())
                .default_value(TAG_SIZE_RANGE.start.to_string().as_str())),
            ]),
            Command::new("decrypt").arg(
                Arg::new("key").help("the hex value used to decrypt the input")
                    .takes_value(true)
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            ),
        ]).get_matches();

    let action = Action::from_str(parsed.subcommand().unwrap().0).unwrap();

    let crypto = Cypher {
        action,
        key: {
            if let Some(key) = parsed.subcommand().unwrap().1.get_one::<String>("key") {
                hex::decode(key).unwrap()
            } else if Action::from_str(parsed.subcommand().unwrap().0).unwrap() == Action::Encrypt {
                let mut rng = thread_rng();
                (0..{
                    if let Some(keySize) =
                        parsed.subcommand().unwrap().1.get_one::<usize>("keySize")
                    {
                        if *keySize < 4 {
                            4
                        } else {
                            *keySize
                        }
                    } else {
                        4
                    }
                })
                    .map(|_| rng.gen_range(0..u8::MAX))
                    .collect()
            } else {
                panic!("Tried to decrypt without suplying a key!")
            }
        },
        input: {
            match action {
                Action::Encrypt => parsed
                    .get_raw("input")
                    .unwrap()
                    .next()
                    .unwrap()
                    .as_bytes()
                    .to_vec(),
                Action::Decrypt => hex::decode(
                    parsed
                        .get_raw("input")
                        .unwrap()
                        .next()
                        .unwrap()
                        .as_bytes()
                        .to_vec(),
                )
                .unwrap(),
            }
        },
        parameters: match action {
            Action::Encrypt => Some(Parameters {
                block_size: *parsed
                    .subcommand()
                    .unwrap()
                    .1
                    .get_one::<u8>("blockSize")
                    .unwrap_or(&BLOCK_SIZE),
                keyed_hash_size: *parsed
                    .subcommand()
                    .unwrap()
                    .1
                    .get_one::<u8>("keyedHashSize")
                    .unwrap_or(&BLOCK_SIZE),
                iv_size: *parsed
                    .subcommand()
                    .unwrap()
                    .1
                    .get_one::<u8>("ivSize")
                    .unwrap_or(&BLOCK_SIZE),
                tag_size: *parsed
                    .subcommand()
                    .unwrap()
                    .1
                    .get_one::<u8>("tagSize")
                    .unwrap_or(&BLOCK_SIZE),
            }),
            Action::Decrypt => None,
        },
    };

    println!(
        "{} Input: {}, Key: {} -> {}",
        match crypto.action {
            Action::Encrypt => "Encrypted",
            Action::Decrypt => "Decrypted",
        }
        .red()
        .bold()
        .underline(),
        match crypto.action {
            Action::Encrypt => {
                if let Ok(decoded) = String::from_utf8(crypto.input.clone()) {
                    decoded
                } else {
                    format!("{}", "The input couldn't be UTF-8 encoded!".bright_red().bold())
                }
            },
            Action::Decrypt => hex::encode(&crypto.input),
        }
        .bright_white(),
        hex::encode(&crypto.key).bright_white(),
        match crypto.action {
            Action::Encrypt => hex::encode(crypto.process().unwrap()),
            Action::Decrypt => {
                match crypto.process() {
                    Ok(decrypted) => {
                        if let Ok(decoded) = String::from_utf8(decrypted.clone()) {
                            decoded
                        } else {
                            let mut writeBuffer = BufWriter::new(File::create(OUT_FILE).unwrap());
                            writeBuffer.write_all(decrypted.as_slice()).unwrap();
                            writeBuffer.flush().unwrap();
                            format!("{}", format!("The output couldn't be UTF-8 encoded, so the output was written as raw bytes in the {} file!", OUT_FILE.bright_white()).bright_red())
                        }
                    }
                    Err(error) => format!("{}", error.bright_red())
                }
            }
        }
        .bright_blue()
        .bold()
        .underline()
    )
}
