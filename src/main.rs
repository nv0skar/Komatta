// Komatta
// Copyright (C) 2022 Oscar
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#![allow(non_snake_case)]

use Komatta::{consts::*, keys::Keys, target::Target, Crypt, Integrity};

use base64::{engine::general_purpose::STANDARD as base64, Engine};
use brotli;
use clap::{Arg, ArgAction, Command};
use colored::*;
use const_format::formatcp;
use hex;
use std::io::Cursor;
use std::{
    ffi::OsString,
    fs::File,
    io::{BufWriter, Write},
    os::unix::prelude::OsStrExt,
    str::FromStr,
};

pub const OUT_FILE: &'static str = "output.txt";

struct Transform {
    value: Vec<u8>,
    hex: bool,
    compress: bool,
}

impl Transform {
    pub fn encode(&self) -> Result<Vec<u8>, String> {
        let mut value = vec![];
        if self.compress {
            if let Err(_) = brotli::BrotliCompress(
                &mut Cursor::new(self.value.clone()),
                &mut value,
                &brotli::enc::BrotliEncoderParams::default(),
            ) {
                return Err("Failed to compress!".to_string());
            }
        } else {
            value = self.value.clone()
        }
        Ok({
            if self.hex {
                hex::encode(value.clone()).as_bytes().to_vec()
            } else {
                base64.encode(value.clone()).as_bytes().to_vec()
            }
        })
    }

    pub fn decode(&self) -> Result<Vec<u8>, String> {
        if let Ok(decoded) = {
            if self.hex {
                if let Ok(hex) = hex::decode(self.value.clone()) {
                    Ok(hex)
                } else {
                    Err(())
                }
            } else {
                if let Ok(decoded) = base64.decode(self.value.clone()) {
                    Ok(decoded)
                } else {
                    Err(())
                }
            }
        } {
            if self.compress {
                let (mut compressed, mut decompressed) = (Cursor::new(decoded), vec![]);
                if let Err(_) = brotli::BrotliDecompress(&mut compressed, &mut decompressed) {
                    return Err("Failed to decompress!".to_string());
                }
                Ok(decompressed)
            } else {
                Ok(decoded)
            }
        } else {
            Err("Failed to decode!".to_string())
        }
    }

    pub fn new(value: Vec<u8>, hex: bool, compress: bool) -> Self {
        Self {
            value,
            hex,
            compress,
        }
    }
}

fn main() {
    let parsed = Command::new(env!("CARGO_PKG_NAME"))
        .version(env!("CARGO_PKG_VERSION"))
        .subcommand_required(true)
        .args([
            Arg::new("input")
                .help("the string to process")
                .required(true)
                .value_parser(clap::value_parser!(OsString)),
            Arg::new("hex")
                .help("encrypted data and keys will be encoded in Base16")
                .long("hex")
                .required(false)
                .action(ArgAction::SetTrue),
            Arg::new("noCompression")
                .help("encrypted data and keys won't be compressed")
                .long("noCompression")
                .required(false)
                .action(ArgAction::SetTrue),
        ])
        .subcommands([
            Command::new("encrypt").args([
                Arg::new("key")
                    .help("the hex value used to encrypt the input")
                    .conflicts_with("keySize")
                    .conflicts_with("sizes")
                    .required(false)
                    .value_parser(clap::value_parser!(String)),
                Arg::new("keySize")
                    .help(formatcp!("if the key is missing, a randomly generated byte stream with the specified size will be generated (accepts {})", CRYPT_KEY_SIZE_VALUE))
                    .long("keySize")
                    .conflicts_with("key")
                    .required(false)
                    .value_parser(clap::value_parser!(u8)),
                Arg::new("noSigning")
                    .help("will disable signing")
                    .long("noSigning")
                    .required(false)
                    .action(ArgAction::SetTrue),
                Arg::new("sizes")
                    .help("set the sizes for the crypt")
                    .long("sizes")
                    .conflicts_with("key")
                    .required(false)
                    .value_names(&["iv size", "block size", "cypher key salt size"])
                    .value_parser(clap::value_parser!(u16)),
            ]),
            Command::new("decrypt").arg(
                Arg::new("key")
                    .help("the hex value used to decrypt the input")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            ),
        ])
        .get_matches();

    let (hex, compress) = (
        *parsed.get_one::<bool>("hex").unwrap_or_else(|| &false),
        !*parsed
            .get_one::<bool>("noCompression")
            .unwrap_or_else(|| &false),
    );

    let action = Target::from_str(parsed.subcommand().unwrap().0).unwrap();
    let params = {
        match action {
            Target::Encrypt => Some(parsed.subcommand().unwrap().1.get_many::<u16>("sizes")),
            Target::Decrypt => None,
        }
    };
    let keys = {
        let key = parsed.subcommand().unwrap().1.get_one::<String>("key");
        match action {
            Target::Encrypt => {
                if let Some(masterKey) = key {
                    Keys::try_from(
                        Transform::new(masterKey.as_bytes().to_vec(), hex, compress)
                            .decode()
                            .unwrap(),
                    )
                    .unwrap()
                } else {
                    Keys::new(
                        {
                            if let Some(mut parameters) = params.clone().unwrap() {
                                match parameters.nth(2) {
                                    Some(size) => Some(*size),
                                    None => None,
                                }
                            } else {
                                None
                            }
                        },
                        None,
                        !*parsed
                            .subcommand()
                            .unwrap()
                            .1
                            .get_one::<bool>("noSigning")
                            .unwrap_or_else(|| &false),
                    )
                    .unwrap()
                }
            }
            Target::Decrypt => {
                if let Some(decryptKey) = key {
                    Keys::try_from(
                        Transform::new(decryptKey.as_bytes().to_vec(), hex, compress)
                            .decode()
                            .unwrap(),
                    )
                    .unwrap()
                } else {
                    panic!("Tried to decrypt without suplying the keys!")
                }
            }
        }
    };
    let input = match action {
        Target::Encrypt => parsed
            .get_raw("input")
            .unwrap()
            .next()
            .unwrap()
            .as_bytes()
            .to_vec(),
        Target::Decrypt => {
            let input = parsed
                .get_raw("input")
                .unwrap()
                .next()
                .unwrap()
                .as_bytes()
                .to_vec();
            Transform::new(input, hex, compress).decode().unwrap()
        }
    };

    let mut crypt: Crypt;

    match action {
        Target::Encrypt => {
            crypt = Crypt::new(
                action,
                keys,
                {
                    if let Some(mut parameters) = params.clone().unwrap() {
                        match parameters.nth(0) {
                            Some(size) => Some(*size),
                            None => None,
                        }
                    } else {
                        None
                    }
                },
                {
                    if let Some(mut parameters) = params.clone().unwrap() {
                        match parameters.nth(1) {
                            Some(size) => Some(*size),
                            None => None,
                        }
                    } else {
                        None
                    }
                },
                input.clone(),
                {
                    match !*parsed
                        .subcommand()
                        .unwrap()
                        .1
                        .get_one::<bool>("noSigning")
                        .unwrap_or_else(|| &false)
                    {
                        true => Integrity::Signed(None),
                        false => Integrity::Unsigned(None),
                    }
                },
            )
        }
        Target::Decrypt => {
            crypt = Crypt::try_from(input.clone()).unwrap();
            crypt.target = Target::Decrypt;
            crypt.keys = keys;
        }
    }

    println!(
        "{} Input: {}, Master Key: {}, Decrypt Key: {} -> {}",
        match crypt.target {
            Target::Encrypt => "Encrypted",
            Target::Decrypt => "Decrypted",
        }
        .red()
        .bold()
        .underline(),
        match crypt.target {
            Target::Encrypt => {
                if let Ok(decoded) = String::from_utf8(crypt.input.clone()) {
                    decoded
                } else {
                    format!("{}", "The input couldn't be UTF-8 encoded!".bright_red().bold())
                }
            },
            Target::Decrypt => {
                String::from_utf8(Transform::new(input.clone(), hex, compress)
                .encode()
                .unwrap()).unwrap()
            },
        }
        .bright_white(),
        {
            let masterKey = TryInto::<Vec<u8>>::try_into(crypt.keys.clone()).unwrap();
            if let Ok(keys) = crypt.keys.signing() {
                if let Some(_) = keys.secret {
                    String::from_utf8(Transform::new(masterKey, hex, compress)
                    .encode()
                    .unwrap()).unwrap()
                } else {
                    format!("{}", "Not available".bright_red().bold())
                }
            } else{
                String::from_utf8(Transform::new(masterKey, hex, compress)
                    .encode()
                    .unwrap()).unwrap()
            }
        }
        .bright_white(),
        match crypt.integrity {
            Integrity::Signed(_) => {
                let decryptKey = TryInto::<Vec<u8>>::try_into(crypt.keys.clone().public().unwrap()).unwrap();
                String::from_utf8(Transform::new(decryptKey, hex, compress)
                    .encode()
                    .unwrap()).unwrap()
            },
            Integrity::Unsigned(_) => format!("{}", "Not available".bright_red().bold())
        }
        .bright_white(),
        match crypt.target {
            Target::Encrypt => {
                let encrypted = TryInto::<Vec<u8>>::try_into({
                    let mut out = crypt.clone();
                    out.input = out.process().unwrap();
                    out
                });
                String::from_utf8(Transform::new(encrypted.unwrap(), hex, compress)
                    .encode()
                    .unwrap()).unwrap()
            },
            Target::Decrypt => {
                match crypt.process() {
                    Ok(decrypted) => {
                        if let Ok(decoded) = String::from_utf8(decrypted.clone()) {
                            decoded
                        } else {
                            let mut writeBuffer = BufWriter::new(File::create(OUT_FILE).unwrap());
                            writeBuffer.write_all(decrypted.as_slice()).unwrap();
                            writeBuffer.flush().unwrap();
                            format!("{}", format!("The output couldn't be UTF-8 encoded, so the output was written as raw bytes in the {} file!", OUT_FILE.bright_white()).bright_red())
                        }
                    }
                    Err(error) => format!("{}", error.bright_red())
                }
            }
        }
        .bright_blue()
        .bold()
        .underline()
    )
}
